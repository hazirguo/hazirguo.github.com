# 虚拟化技术大观


## 硬件虚拟化

1964年 IBM M44/44X 世界上第一个支持虚拟化的系统，能够在一台物理机上虚拟出多个 IBM 7044 大型机。使用的虚拟化方法是：**分时复用**，每个时间片运行一个单独的实例。

“任务级”或“进程级”的虚拟化，从概念上延续至今，LXC 和 OpenVZ 就是操作系统级虚拟化。

依赖于定制的硬件来实现虚拟化的技术，称为“硬件虚拟化”。

现在大多虚拟化技术技术都是以软件为主，硬件为辅。


## 从模拟执行到二进制翻译


“模拟执行”  --->  x86 模拟器 Bochs

“动态指令翻译”：程序之行的过程中，能翻译的部分翻译成目标架构的机器码直接执行，不能翻译的部分就陷入到模拟器里，模拟执行特权指令，再对后面的代码进行翻译。

Qemu  动态二进制翻译技术的虚拟化软件，模拟执行多种处理器架构，无修改地运行这些构架上的操作系统。

Intel x86 平台有四个特权级 Ring0~3，主机操作系统内核运行在 Ring0，用户程序运行在 Ring3，虚拟机操作系统内核则运行在 Ring1，当虚拟机系统需要之行某条特权指令时，VMM 就会捕获它，并模拟执行这条特权指令，再返回到虚拟机系统。为了提高性能，有时会利用到动态而进行翻译技术，在运行前把这些特权指令替换成 VMM API 的指令。

![](https://bojieli.com/wp-content/uploads/2014/12/9c37a75e8e2164f50ffe76681c6d4522.png)


## 请虚拟机系统和 CPU 来帮忙

动态二进制翻译虽然比模拟执行快很多，但由于每条特权指令都要到 VMM 里绕一圈（模拟执行），因此离物理机性能还有差距。

解决方法：

1. 请虚拟机操作系统帮忙 --》 半虚拟化
2. 让 CPU 帮忙 --》 硬件辅助虚拟化


### 半虚拟化

修改虚拟机系统的内核

虚拟机系统与虚拟化层（主机系统）不再是严格的上下级关系，而是互信合作的关系。x86 架构下，虚拟化层和虚拟机系统的内核都运行在 Ring0.

![](https://bojieli.com/wp-content/uploads/2014/12/98ce27bf0640053df5db977f6c41cc3e.png)


虚拟机系统的内核需要经过特殊修改，把特权指令改成对虚拟化层 API 的调用。


### 硬件辅助的虚拟化

二进制翻译主要开销在”捕获“虚拟机系统的特权指令上，这部分工作可以交给 CPU 来做：

* Intel 的解决方案是 VT-x，在原有的四个特权级基础上，增加了一个专供 VMM 使用的 Root Mode。

![](https://bojieli.com/wp-content/uploads/2014/12/05112238fed78cb9df19c07ec82544cf.png)

为了方便半虚拟化中用 API 调用替换 CPU 异常捕获，Intel 提供了从虚拟机（Non-Root Mode）到虚拟机管理器（Root Mode）的”系统调用“——VMCALL指令。

* AMD 的解决方案是 AMD-V




## CPU 虚拟化不是一切

### 内存虚拟化

### 设备虚拟化













https://bojieli.com/2014/12/virtualization-overview/